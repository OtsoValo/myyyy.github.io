<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Finding and Replacing Objects in Python &ndash; good-bye</title>
        <meta name="description" content="More reflection than you cared to ask for &#124; Ben Kurtovic's blog">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/png" href="/static/favicon.png" />
        <link rel="stylesheet" href="/static/main.css" />
        <link rel="stylesheet" href="/static/syntax.css" />
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Ben Kurtovic" />
        <script src="//code.jquery.com/jquery-1.12.3.min.js" integrity="sha256-aaODHAgvwQW1bFOGXMeX+pC4PZIPsvn2h1sArYOhgXQ=" crossorigin="anonymous"></script>
        <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="/static/main.js"></script>
    </head>
    <body>
        <div id="banner">
            <a href="/">
                <img src="/static/avatar.png" title="good bye" alt="SYFY" />
                <h1>再 见。</h1>
            </a>
        </div>
        <div id="container">
            <h1>Finding and Replacing Objects in Python</h1>
<div id="content">
    <ul id="post-info">
        <li><span><i class="fa fa-tag"></i> Tags:</span>
            
                <a href="/#Python" class="post-tag">Python</a>
            
        <li><span><i class="fa fa-clock-o"></i> Date:</span> January 28, 2015</li>
        <li><span><i class="fa fa-comments"></i></span> <a href="#disqus_thread">Jump to comments</a></li>
    </ul>
    <div id="post">
        <p>Today, we’re going to demonstrate a fairly evil thing in Python, which I call
<em>object replacement</em>.</p>

<p>Say you have some program that’s been running for a while, and a particular
object has made its way throughout your code. It lives inside lists, class
attributes, maybe even inside some closures. You want to completely replace
this object with another one; that is to say, you want to find all references
to object <code class="highlighter-rouge">A</code> and replace them with object <code class="highlighter-rouge">B</code>, enabling <code class="highlighter-rouge">A</code> to be garbage
collected. This has some interesting implications for special object types. If
you have methods that are bound to <code class="highlighter-rouge">A</code>, you want to rebind them to <code class="highlighter-rouge">B</code>. If <code class="highlighter-rouge">A</code>
is a class, you want all instances of <code class="highlighter-rouge">A</code> to become instances of <code class="highlighter-rouge">B</code>. And so
on.</p>

<p><em>But why on Earth would you want to do that?</em> you ask. I’ll focus on a concrete
use case in a future post, but for now, I imagine this could be useful in some
kind of advanced unit testing situation with mock objects. Still, it’s fairly
insane, so let’s leave it primarily as an intellectual exercise.</p>

<p>This article is written for <a href="https://en.wikipedia.org/wiki/CPython">CPython</a>
2.7.<sup><a id="ref1" href="#fn1">[1]</a></sup></p>

<h2 id="review">Review</h2>

<p>First, a recap on terminology here. You can skip this section if you know
Python well.</p>

<p>In Python, <em>names</em> are what most languages call “variables”. They reference
<em>objects</em>. So when we do:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span></code></pre></figure>

<p>…we are creating a list object with four integers, and binding it to the name
<code class="highlighter-rouge">a</code>. In graph form:<sup><a id="ref2" href="#fn2">[2]</a></sup></p>

<svg width="223pt" height="44pt" viewbox="0.00 0.00 223.01 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)"><polygon fill="white" stroke="none" points="-4,4 -4,-40 219.012,-40 219.012,4 -4,4" /><g id="node1" class="node"><title>L</title><polygon fill="none" stroke="black" stroke-width="0.5" points="215.018,-36 126.994,-36 126.994,-0 215.018,-0 215.018,-36" /><text text-anchor="middle" x="171.006" y="-15" font-family="Courier,monospace" font-size="10.00">[1, 2, 3, 4]</text></g><g id="node2" class="node"><title>a</title><ellipse fill="none" stroke="black" stroke-width="0.5" cx="27" cy="-18" rx="27" ry="18" /><text text-anchor="middle" x="27" y="-13.8" font-family="Courier,monospace" font-size="14.00">a</text></g><g id="edge1" class="edge"><title>a&#45;&gt;L</title><path fill="none" stroke="black" stroke-width="0.5" d="M54.0461,-18C72.2389,-18 97.1211,-18 119.173,-18" /><polygon fill="black" stroke="black" stroke-width="0.5" points="119.339,-20.6251 126.839,-18 119.339,-15.3751 119.339,-20.6251" /></g></g></svg>

<p>In each of the following examples, we are creating new <em>references</em> to the
list object, but we are never duplicating it. Each reference points to the same
memory address (which you can get using <code class="highlighter-rouge">id(a)</code>).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">b</span> <span class="o">=</span> <span class="n">a</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">c</span> <span class="o">=</span> <span class="n">SomeContainerClass</span><span class="p">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">a</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">L</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></code></pre></figure>

<svg width="254pt" height="234pt" viewbox="0.00 0.00 253.96 234.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 238)"><polygon fill="white" stroke="none" points="-4,4 -4,-238 249.96,-238 249.96,4 -4,4" /><g id="clust3" class="cluster"><title>cluster0</title><polygon fill="none" stroke="black" stroke-width="0.5" points="8,-8 8,-82 78,-82 78,-8 8,-8" /><text text-anchor="middle" x="43" y="-66.8" font-family="Courier,monospace" font-size="14.00">d</text></g><g id="node1" class="node"><title>obj</title><polygon fill="none" stroke="black" stroke-width="0.5" points="245.966,-153 157.943,-153 157.943,-117 245.966,-117 245.966,-153" /><text text-anchor="middle" x="201.954" y="-132" font-family="Courier,monospace" font-size="10.00">[1, 2, 3, 4]</text></g><g id="node2" class="node"><title>a</title><ellipse fill="none" stroke="black" stroke-width="0.5" cx="43" cy="-216" rx="27" ry="18" /><text text-anchor="middle" x="43" y="-211.8" font-family="Courier,monospace" font-size="14.00">a</text></g><g id="edge1" class="edge"><title>a&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M64.8423,-205.244C88.7975,-192.881 128.721,-172.278 159.152,-156.573" /><polygon fill="black" stroke="black" stroke-width="0.5" points="160.422,-158.872 165.883,-153.1 158.014,-154.206 160.422,-158.872" /></g><g id="node3" class="node"><title>b</title><ellipse fill="none" stroke="black" stroke-width="0.5" cx="43" cy="-162" rx="27" ry="18" /><text text-anchor="middle" x="43" y="-157.8" font-family="Courier,monospace" font-size="14.00">b</text></g><g id="edge2" class="edge"><title>b&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M69.2174,-157.662C90.9996,-153.915 123.147,-148.385 150.231,-143.726" /><polygon fill="black" stroke="black" stroke-width="0.5" points="150.777,-146.295 157.724,-142.437 149.887,-141.121 150.777,-146.295" /></g><g id="node4" class="node"><title>c</title><ellipse fill="none" stroke="black" stroke-width="0.5" cx="43" cy="-108" rx="41.897" ry="18" /><text text-anchor="middle" x="43" y="-103.8" font-family="Courier,monospace" font-size="14.00">c.data</text></g><g id="edge3" class="edge"><title>c&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M82.3954,-114.605C102.772,-118.11 128.077,-122.463 150.069,-126.247" /><polygon fill="black" stroke="black" stroke-width="0.5" points="149.86,-128.874 157.697,-127.559 150.75,-123.7 149.86,-128.874" /></g><g id="node5" class="node"><title>L</title><ellipse fill="none" stroke="black" stroke-width="0.5" cx="43" cy="-34" rx="27" ry="18" /><text text-anchor="middle" x="43" y="-29.8" font-family="Courier,monospace" font-size="14.00">L</text></g><g id="edge4" class="edge"><title>L&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M62.9324,-46.183C88.5083,-62.6411 134.554,-92.2712 166.386,-112.755" /><polygon fill="black" stroke="black" stroke-width="0.5" points="165.223,-115.128 172.951,-116.98 168.064,-110.714 165.223,-115.128" /></g></g></svg>

<p>Note that these references are all equal. <code class="highlighter-rouge">a</code> is no more valid a name for the
list than <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c.data</code>, or <code class="highlighter-rouge">L</code> (or <code class="highlighter-rouge">d.func_closure[0].cell_contents</code> to the
outside world). As a result, if you delete one of these references—explicitly
with <code class="highlighter-rouge">del a</code>, or implicitly if a name goes out of scope—then the other
references are still around, and object continues to exist. If all of an
object’s references disappear, then Python’s garbage collector should eliminate
it.</p>

<h2 id="dead-ends">Dead ends</h2>

<p>My first thought when approaching this problem was to physically write over the
memory where our target object is stored. This can be done using
<a href="https://docs.python.org/2/library/ctypes.html#ctypes.memmove"><code class="highlighter-rouge">ctypes.memmove()</code></a>
from the Python standard library:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; class A(object): pass
...
&gt;&gt;&gt; class B(object): pass
...
&gt;&gt;&gt; obj = A()
&gt;&gt;&gt; print obj
&lt;__main__.A object at 0x10e3e1190&gt;
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; ctypes.memmove(id(A), id(B), object.__sizeof__(A))
140576340136752
&gt;&gt;&gt; print obj
&lt;__main__.B object at 0x10e3e1190&gt;</code></pre></figure>

<p>What we are doing here is overwriting the fields of the <code class="highlighter-rouge">A</code> instance of the
<a href="https://github.com/python/cpython/blob/2.7/Include/classobject.h#L12"><code class="highlighter-rouge">PyClassObject</code> C struct</a>
with fields from the <code class="highlighter-rouge">B</code> struct instance. As a result, they now share various
properties, such as their attribute dictionaries
(<a href="https://docs.python.org/2/reference/datamodel.html#the-standard-type-hierarchy"><code class="highlighter-rouge">__dict__</code></a>).
So, we can do things like this:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; B.foo = 123
&gt;&gt;&gt; obj.foo
123</code></pre></figure>

<p>However, there are clear issues. What we’ve done is create a
<a href="https://en.wikipedia.org/wiki/Object_copy#Shallow_copy"><em>shallow copy</em></a>.
Therefore, <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are still distinct objects, so certain changes made to
one will not be replicated to the other:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; A is B
False
&gt;&gt;&gt; B.__name__ = "C"
&gt;&gt;&gt; A.__name__
'B'</code></pre></figure>

<p>Also, this won’t work if <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are different sizes, since we will be
either reading from or writing to memory that we don’t necessarily own:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; A = ()
&gt;&gt;&gt; B = []
&gt;&gt;&gt; print A.__sizeof__(), B.__sizeof__()
24 40
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; ctypes.memmove(id(A), id(B), A.__sizeof__())
4321271888
Python(33575,0x7fff76925300) malloc: *** error for object 0x6f: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
Abort trap: 6</code></pre></figure>

<p>Oh, and there’s a bit of a problem when we deallocate these objects, too…</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; A = []
&gt;&gt;&gt; B = range(8)
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; ctypes.memmove(id(A), id(B), A.__sizeof__())
4514685728
&gt;&gt;&gt; print A
[0, 1, 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; del A
&gt;&gt;&gt; del B
Segmentation fault: 11</code></pre></figure>

<h2 id="fishing-for-references-with-guppy">Fishing for references with Guppy</h2>

<p>A more appropriate solution is finding all of the <em>references</em> to the old
object, and then updating them to point to the new object, rather than
replacing the old object directly.</p>

<p>But how do we track references? Fortunately, there’s a library called
<a href="http://guppy-pe.sourceforge.net/">Guppy</a> that allows us to do this. Often used
for diagnosing memory leaks, we can take advantage of its robust object
tracking features here. Install it with <a href="https://pypi.python.org/pypi/pip">pip</a>
(<code class="highlighter-rouge">pip install guppy</code>).</p>

<p>I’ve always found Guppy hard to use (as many debuggers are, though justified by
the complexity of the task involved), so we’ll begin with a feature demo before
delving into the actual problem.</p>

<h3 id="feature-demonstration">Feature demonstration</h3>

<p>Guppy’s interface is deceptively simple. We begin by calling
<a href="http://guppy-pe.sourceforge.net/guppy.html#kindnames.guppy.hpy"><code class="highlighter-rouge">guppy.hpy()</code></a>,
to expose the Heapy interface, which is the component of Guppy with the
features we want:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import guppy
&gt;&gt;&gt; hp = guppy.hpy()
&gt;&gt;&gt; hp
Top level interface to Heapy.
Use eg: hp.doc for more info on hp.</code></pre></figure>

<p>Calling
<a href="http://guppy-pe.sourceforge.net/heapy_Use.html#heapykinds.Use.heap"><code class="highlighter-rouge">hp.heap()</code></a>
shows us a table of the objects known to Guppy, grouped together
(mathematically speaking,
<a href="https://en.wikipedia.org/wiki/Partition_of_a_set"><em>partitioned</em></a>) by
type<sup><a id="ref3" href="#fn3">[3]</a></sup> and sorted by how much space
they take up in memory:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; heap = hp.heap()
&gt;&gt;&gt; heap
Partition of a set of 45761 objects. Total size = 4699200 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  15547  34  1494736  32   1494736  32 str
     1   8356  18   770272  16   2265008  48 tuple
     2    346   1   452080  10   2717088  58 dict (no owner)
     3  13685  30   328440   7   3045528  65 int
     4     71   0   221096   5   3266624  70 dict of module
     5   1652   4   211456   4   3478080  74 types.CodeType
     6    199   0   210856   4   3688936  79 dict of type
     7   1614   4   193680   4   3882616  83 function
     8    199   0   177008   4   4059624  86 type
     9    124   0   135328   3   4194952  89 dict of class
&lt;91 more rows. Type e.g. '_.more' to view.&gt;</code></pre></figure>

<p>This object (called an
<a href="http://guppy-pe.sourceforge.net/heapy_UniSet.html#heapykinds.IdentitySet"><code class="highlighter-rouge">IdentitySet</code></a>)
looks bizarre, but it can be treated roughly like a list. If we want to take a
look at strings, we can do <code class="highlighter-rouge">heap[0]</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; heap[0]
Partition of a set of 22606 objects. Total size = 2049896 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0  22606 100  2049896 100   2049896 100 str</code></pre></figure>

<p>This isn’t very useful, though. What we really want to do is re-partition this
subset using another relationship. There are a number of options, such as:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; heap[0].byid  # Group by object ID; each subset therefore has one element
Set of 22606 &lt;str&gt; objects. Total size = 2049896 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0     7480   0.4      7480   0.4 'The class Bi... copy of S.\n'
     1     4872   0.2     12352   0.6 "Support for ... 'error'.\n\n"
     2     4760   0.2     17112   0.8 'Heap queues\...at Art! :-)\n'
     3     4760   0.2     21872   1.1 'Heap queues\...at Art! :-)\n'
     4     3896   0.2     25768   1.3 'This module ...ng function\n'
     5     3824   0.2     29592   1.4 'The type of ...call order.\n'
     6     3088   0.2     32680   1.6 't\x00\x00|\x...x00|\x02\x00S'
     7     2992   0.1     35672   1.7 'HeapView(roo... size, etc.\n'
     8     2808   0.1     38480   1.9 'Directory tr...ories\n\n    '
     9     2640   0.1     41120   2.0 'The class No... otherwise.\n'
&lt;22596 more rows. Type e.g. '_.more' to view.&gt;</code></pre></figure>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; heap[0].byrcs  # Group by what types of objects reference the strings
Partition of a set of 22606 objects. Total size = 2049896 bytes.
 Index  Count   %     Size   % Cumulative  % Referrers by Kind (class / dict of class)
     0   6146  27   610752  30    610752  30 types.CodeType
     1   5304  23   563984  28   1174736  57 tuple
     2   4104  18   237536  12   1412272  69 dict (no owner)
     3   1959   9   139880   7   1552152  76 list
     4    564   2   136080   7   1688232  82 function, tuple
     5    809   4    97896   5   1786128  87 dict of module
     6    346   2    71760   4   1857888  91 dict of type
     7    365   2    19408   1   1877296  92 dict of module, tuple
     8    192   1    16176   1   1893472  92 dict (no owner), list
     9    232   1    11784   1   1905256  93 dict of class, function, tuple, types.CodeType
&lt;229 more rows. Type e.g. '_.more' to view.&gt;</code></pre></figure>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; heap[0].byvia  # Group by how the strings are related to their referrers
Partition of a set of 22606 objects. Total size = 2049896 bytes.
 Index  Count   %     Size   % Cumulative  % Referred Via:
     0   2656  12   420456  21    420456  21 '[0]'
     1   2095   9   259008  13    679464  33 '.co_code'
     2   2095   9   249912  12    929376  45 '.co_filename'
     3    564   2   136080   7   1065456  52 '.func_doc', '[0]'
     4    243   1   103528   5   1168984  57 "['__doc__']"
     5   1930   9   100584   5   1269568  62 '.co_lnotab'
     6    502   2    31128   2   1300696  63 '[1]'
     7    306   1    16272   1   1316968  64 '[2]'
     8    242   1    12960   1   1329928  65 '[3]'
     9    184   1     9872   0   1339800  65 '[4]'
&lt;7323 more rows. Type e.g. '_.more' to view.&gt;</code></pre></figure>

<p>From this, we can see that the plurality of memory devoted to strings is taken
up by those referenced by code objects (<code class="highlighter-rouge">types.CodeType</code> represents
Python code—accessible from a non-C-defined function through
<code class="highlighter-rouge">func.func_code</code>—and contains things like the names of its local variables and
the actual sequence of opcodes that make it up).</p>

<p>For fun, let’s pick a random string.</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import random
&gt;&gt;&gt; obj = heap[0].byid[random.randrange(0, heap[0].count)]
&gt;&gt;&gt; obj
Set of 1 &lt;str&gt; object. Total size = 176 bytes.
 Index     Size   %   Cumulative  %   Representation (limited)
     0      176 100.0       176 100.0 'Define names...not listed.\n'</code></pre></figure>

<p>Interesting. Since this heap subset contains only one element, we can use
<a href="http://guppy-pe.sourceforge.net/heapy_UniSet.html#heapykinds.IdentitySetSingleton.theone"><code class="highlighter-rouge">.theone</code></a>
to get the actual object represented here:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; obj.theone
'Define names for all type symbols known in the standard interpreter.\n\nTypes that are part of optional modules (e.g. array) are not listed.\n'</code></pre></figure>

<p>Looks like the docstring for the
<a href="https://docs.python.org/2/library/types.html"><code class="highlighter-rouge">types</code></a> module. We can confirm
by using
<a href="http://guppy-pe.sourceforge.net/heapy_UniSet.html#heapykinds.IdentitySet.referrers"><code class="highlighter-rouge">.referrers</code></a>
to get the set of objects that refer to objects in the given set:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; obj.referrers
Partition of a set of 1 object. Total size = 3352 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1 100     3352 100      3352 100 dict of module</code></pre></figure>

<p>This is <code class="highlighter-rouge">types.__dict__</code> (since the docstring we got is actually stored as
<code class="highlighter-rouge">types.__dict__["__doc__"]</code>), so if we use <code class="highlighter-rouge">.referrers</code> again:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; obj.referrers.referrers
Partition of a set of 1 object. Total size = 56 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1 100       56 100        56 100 module
&gt;&gt;&gt; obj.referrers.referrers.theone
&lt;module 'types' from '/usr/local/Cellar/python/2.7.8_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/types.pyc'&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; types.__doc__ is obj.theone
True</code></pre></figure>

<p><em>But why did we find an object in the <code class="highlighter-rouge">types</code> module if we never imported it?</em>
Well, let’s see. We can use
<a href="http://guppy-pe.sourceforge.net/heapy_Use.html#heapykinds.Use.iso"><code class="highlighter-rouge">hp.iso()</code></a>
to get the Heapy set consisting of a single given object:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; hp.iso(types)
Partition of a set of 1 object. Total size = 56 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1 100       56 100        56 100 module</code></pre></figure>

<p>Using a similar procedure as before, we see that <code class="highlighter-rouge">types</code> is imported by the
<a href="https://docs.python.org/2/library/traceback.html"><code class="highlighter-rouge">traceback</code></a> module:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; hp.iso(types).referrers
Partition of a set of 10 objects. Total size = 25632 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      2  20    13616  53     13616  53 dict (no owner)
     1      5  50     9848  38     23464  92 dict of module
     2      1  10     1048   4     24512  96 dict of guppy.etc.Glue.Interface
     3      1  10     1048   4     25560 100 dict of guppy.etc.Glue.Share
     4      1  10       72   0     25632 100 tuple
&gt;&gt;&gt; hp.iso(types).referrers[1].byid
Set of 5 &lt;dict of module&gt; objects. Total size = 9848 bytes.
 Index     Size   %   Cumulative  %   Owner Name
     0     3352  34.0      3352  34.0 traceback
     1     3352  34.0      6704  68.1 warnings
     2     1048  10.6      7752  78.7 __main__
     3     1048  10.6      8800  89.4 abc
     4     1048  10.6      9848 100.0 guppy.etc.Glue</code></pre></figure>

<p>…and that is imported by
<a href="https://docs.python.org/2/library/site.html"><code class="highlighter-rouge">site</code></a>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import traceback
&gt;&gt;&gt; hp.iso(traceback).referrers
Partition of a set of 3 objects. Total size = 15992 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1  33    12568  79     12568  79 dict (no owner)
     1      1  33     3352  21     15920 100 dict of module
     2      1  33       72   0     15992 100 tuple
&gt;&gt;&gt; hp.iso(traceback).referrers[1].byid
Set of 1 &lt;dict of module&gt; object. Total size = 3352 bytes.
 Index     Size   %   Cumulative  %   Owner Name
     0     3352 100.0      3352 100.0 site</code></pre></figure>

<p>Since <code class="highlighter-rouge">site</code> is imported by Python on startup, we’ve figured out why objects
from <code class="highlighter-rouge">types</code> exist, even though we’ve never used them.</p>

<p>We’ve learned something important, too. When objects are stored as ordinary
attributes of a parent object (like <code class="highlighter-rouge">types.__doc__</code>, <code class="highlighter-rouge">traceback.types</code>, and
<code class="highlighter-rouge">site.traceback</code> from above), they are not referenced directly by the parent
object, but by that object’s <code class="highlighter-rouge">__dict__</code> attribute. Therefore, if we want to
replace <code class="highlighter-rouge">A</code> with <code class="highlighter-rouge">B</code> and <code class="highlighter-rouge">A</code> is an attribute of <code class="highlighter-rouge">C</code>, we (probably) don’t need
to know anything special about <code class="highlighter-rouge">C</code>—just how to modify dictionaries.</p>

<p>A good Guppy/Heapy tutorial, while a bit old and incomplete, can be found on
<a href="http://smira.ru/wp-content/uploads/2011/08/heapy.html">Andrey Smirnov’s website</a>.</p>

<h2 id="examining-paths">Examining paths</h2>

<p>Let’s set up an example replacement using class instances:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span></code></pre></figure>

<p>Suppose we want to replace <code class="highlighter-rouge">a</code> with <code class="highlighter-rouge">b</code>. From the demo above, we know that we
can get the Heapy set of a single object using <code class="highlighter-rouge">hp.iso()</code>. We also know we can
use <code class="highlighter-rouge">.referrers</code> to get the set of objects that reference the given object:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import guppy
&gt;&gt;&gt; hp = guppy.hpy()
&gt;&gt;&gt; print hp.iso(a).referrers
Partition of a set of 1 object. Total size = 1048 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1 100     1048 100      1048 100 dict of module</code></pre></figure>

<p><code class="highlighter-rouge">a</code> is only referenced by one object, which makes sense, since we’ve only used
it in one place—as a local variable—meaning <code class="highlighter-rouge">hp.iso(a).referrers.theone</code> must
be <a href="https://docs.python.org/2/library/functions.html#locals"><code class="highlighter-rouge">locals()</code></a>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; hp.iso(a).referrers.theone is locals()
True</code></pre></figure>

<p>However, there is a more useful feature available to us:
<a href="http://guppy-pe.sourceforge.net/heapy_UniSet.html#heapykinds.IdentitySet.pathsin"><code class="highlighter-rouge">.pathsin</code></a>.
This also returns references to the given object, but instead of a Heapy set,
it is a list of <code class="highlighter-rouge">Path</code> objects. These are more useful since they tell us not
only <em>what</em> objects are related to the given object, but <em>how</em> they are
related.</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; print hp.iso(a).pathsin
 0: Src['a']</code></pre></figure>

<p>This looks very ambiguous. However, we find that we can extract the source of
the reference using <code class="highlighter-rouge">.src</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; path = hp.iso(a).pathsin[0]
&gt;&gt;&gt; print path.src
Partition of a set of 1 object. Total size = 1048 bytes.
 Index  Count   %     Size   % Cumulative  % Kind (class / dict of class)
     0      1 100     1048 100      1048 100 dict of module
&gt;&gt;&gt; path.src.theone is locals()
True</code></pre></figure>

<p>…and, we can examine the type of relation by looking at <code class="highlighter-rouge">.path[1]</code> (the
actual reason for this isn’t worth getting into, due to Guppy’s lack of
documentation on the subject):</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; relation = path.path[1]
&gt;&gt;&gt; relation
&lt;guppy.heapy.Path.Based_R_INDEXVAL object at 0x100f38230&gt;</code></pre></figure>

<p>We notice that <code class="highlighter-rouge">relation</code> is a <code class="highlighter-rouge">Based_R_INDEXVAL</code> object. Sounds bizarre, but
this tells us that <code class="highlighter-rouge">a</code> is a particular indexed value of <code class="highlighter-rouge">path.src</code>. What index?
We can get this using <code class="highlighter-rouge">relation.r</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; rel = relation.r
&gt;&gt;&gt; print rel
a</code></pre></figure>

<p>Ah ha! So now we know that <code class="highlighter-rouge">a</code> is equal to the reference source (i.e.,
<code class="highlighter-rouge">path.src.theone</code>) indexed by <code class="highlighter-rouge">rel</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; path.src.theone[rel] is a
True</code></pre></figure>

<p>But <code class="highlighter-rouge">path.src.theone</code> is just a dictionary, meaning we know how to modify it
very easily:<sup><a id="ref4" href="#fn4">[4]</a></sup></p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; path.src.theone[rel] = b
&gt;&gt;&gt; a
&lt;__main__.B object at 0x100dae090&gt;
&gt;&gt;&gt; a is b
True</code></pre></figure>

<p>Bingo. We’ve successfully replaced <code class="highlighter-rouge">a</code> with <code class="highlighter-rouge">b</code>, using a general method that
should work for any case where <code class="highlighter-rouge">a</code> is in a dictionary-like object.</p>

<h2 id="handling-different-reference-types">Handling different reference types</h2>

<p>We’ll continue by wrapping this code up in a nice function, which we will
expand as we go:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">guppy</span>
<span class="kn">from</span> <span class="nn">guppy.heapy</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">hp</span> <span class="o">=</span> <span class="n">guppy</span><span class="o">.</span><span class="n">hpy</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">hp</span><span class="o">.</span><span class="n">iso</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">pathsin</span><span class="p">:</span>
        <span class="n">relation</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relation</span><span class="p">,</span> <span class="n">Path</span><span class="o">.</span><span class="n">R_INDEXVAL</span><span class="p">):</span>
            <span class="n">path</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">theone</span><span class="p">[</span><span class="n">relation</span><span class="o">.</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span></code></pre></figure>

<h3 id="dictionaries-lists-and-tuples">Dictionaries, lists, and tuples</h3>

<p>As noted above, this is versatile to handle many dictionary-like situations,
including <code class="highlighter-rouge">__dict__</code>, which means we already know how to replace object
attributes:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt;
&gt;&gt;&gt; class X(object):
...     pass
...
&gt;&gt;&gt; X.cattr = a
&gt;&gt;&gt; x = X()
&gt;&gt;&gt; x.iattr = a
&gt;&gt;&gt; d1 = {1: a}
&gt;&gt;&gt; d2 = [{1: {0: ("foo", "bar", {"a": a, "b": b})}}]
&gt;&gt;&gt;
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt;
&gt;&gt;&gt; print a
&lt;__main__.B object at 0x1042b9910&gt;
&gt;&gt;&gt; print X.cattr
&lt;__main__.B object at 0x1042b9910&gt;
&gt;&gt;&gt; print x.iattr
&lt;__main__.B object at 0x1042b9910&gt;
&gt;&gt;&gt; print d1[1]
&lt;__main__.B object at 0x1042b9910&gt;
&gt;&gt;&gt; print d2[0][1][0][2]["a"]
&lt;__main__.B object at 0x1042b9910&gt;</code></pre></figure>

<p>Lists can be handled exactly the same as dictionaries, although the keys in
this case (i.e., <code class="highlighter-rouge">relation.r</code>) will always be integers.</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; L = [0, 1, 2, a, b]
&gt;&gt;&gt; print L
[0, 1, 2, &lt;__main__.A object at 0x104598950&gt;, &lt;__main__.B object at 0x104598910&gt;]
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; print L
[0, 1, 2, &lt;__main__.B object at 0x104598910&gt;, &lt;__main__.B object at 0x104598910&gt;]</code></pre></figure>

<p>Tuples are interesting. We can’t modify them directly because they’re
immutable, but we <em>can</em> create a new tuple with the new value, and then replace
that tuple just like we replaced our original object:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">        <span class="c"># Meanwhile, in replace()...</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relation</span><span class="p">,</span> <span class="n">Path</span><span class="o">.</span><span class="n">R_INDEXVAL</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">theone</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">relation</span><span class="o">.</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span>
                <span class="n">replace</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source</span><span class="p">[</span><span class="n">relation</span><span class="o">.</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span></code></pre></figure>

<p>As a result:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; t1 = (0, 1, 2, a)
&gt;&gt;&gt; t2 = (0, (1, (2, (3, (4, (5, (a,)))))))
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; print t1
(0, 1, 2, &lt;__main__.B object at 0x104598e50&gt;)
&gt;&gt;&gt; print t2
(0, (1, (2, (3, (4, (5, (&lt;__main__.B object at 0x104598e50&gt;,)))))))</code></pre></figure>

<h3 id="bound-methods">Bound methods</h3>

<p>Here’s a fun one. Let’s upgrade our definitions of <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span></code></pre></figure>

<p>After replacing <code class="highlighter-rouge">a</code> with <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">a.func</code> no longer exists, as we’d expect:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; a.func()
&lt;__main__.A object at 0x10c4a5b10&gt;
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; a.func()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'B' object has no attribute 'func'</code></pre></figure>

<p>But what if we save a reference to <code class="highlighter-rouge">a.func</code> before the replacement?</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; f = a.func
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; f()
&lt;__main__.A object at 0x10c4b6090&gt;</code></pre></figure>

<p>Hmm. So <code class="highlighter-rouge">f</code> has kept a reference to <code class="highlighter-rouge">a</code> somehow, but not in a dictionary-like
object. So where is it?</p>

<p>Well, we can reveal it with the attribute <code class="highlighter-rouge">f.__self__</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; f.__self__
&lt;__main__.A object at 0x10c4b6090&gt;</code></pre></figure>

<p>Unfortunately, this attribute is magical and we can’t write to it directly:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; f.__self__ = b
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: readonly attribute</code></pre></figure>

<p>Python clearly doesn’t want us to re-bind bound methods, and a reasonable
person would give up here, but we still have a few tricks up our sleeve. Let’s
examine the internal C structure of bound methods,
<a href="https://github.com/python/cpython/blob/2.7/Include/classobject.h#L31"><code class="highlighter-rouge">PyMethodObject</code></a>:</p>

<svg width="559pt" height="200pt" viewbox="0.00 18.00 559.03 200.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 226)"><polygon fill="white" stroke="none" points="-4,4 -4,-226 555.032,-226 555.032,4 -4,4" /><g id="clust2" class="cluster"><title>cluster</title><polygon fill="none" stroke="black" stroke-width="0" points="8,-8 8,-214 272,-214 272,-8 8,-8" /><text text-anchor="middle" x="140" y="-14.8" font-family="Courier,monospace" font-size="14.00">PyMethodObject</text></g><g id="node1" class="node"><title>obj</title><polygon fill="none" stroke="black" stroke-width="0.5" points="551.048,-110 336.984,-110 336.984,-74 551.048,-74 551.048,-110" /><text text-anchor="middle" x="444.016" y="-89" font-family="Courier,monospace" font-size="10.00">&lt;__main__.A object at 0xdeadbeef&gt;</text></g><g id="node2" class="node"><title>struct</title><polygon fill="#eeeeee" stroke="none" points="24,-182 24,-202 256,-202 256,-182 24,-182" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-182 24,-202 256,-202 256,-182 24,-182" /><text text-anchor="start" x="27" y="-188.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _object* </text><text text-anchor="start" x="161.422" y="-188.8" font-family="Courier,monospace" font-style="oblique" font-size="14.00" fill="#666666">_ob_next</text><polygon fill="#eeeeee" stroke="none" points="24,-162 24,-182 256,-182 256,-162 24,-162" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-162 24,-182 256,-182 256,-162 24,-162" /><text text-anchor="start" x="27" y="-168.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _object* </text><text text-anchor="start" x="161.422" y="-168.8" font-family="Courier,monospace" font-style="oblique" font-size="14.00" fill="#666666">_ob_prev</text><polygon fill="#eeeeee" stroke="none" points="24,-142 24,-162 256,-162 256,-142 24,-142" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-142 24,-162 256,-162 256,-142 24,-142" /><text text-anchor="start" x="27" y="-148.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">Py_ssize_t </text><text text-anchor="start" x="119.415" y="-148.8" font-family="Courier,monospace" font-size="14.00">ob_refcnt</text><polygon fill="#eeeeee" stroke="none" points="24,-122 24,-142 256,-142 256,-122 24,-122" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-122 24,-142 256,-142 256,-122 24,-122" /><text text-anchor="start" x="26.5815" y="-128.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _typeobject* </text><text text-anchor="start" x="194.609" y="-128.8" font-family="Courier,monospace" font-size="14.00">ob_type</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-102 24,-122 256,-122 256,-102 24,-102" /><text text-anchor="start" x="27" y="-108.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-108.8" font-family="Courier,monospace" font-size="14.00">im_func</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-82 24,-102 256,-102 256,-82 24,-82" /><text text-anchor="start" x="27" y="-88.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-88.8" font-family="Courier,monospace" font-size="14.00">im_self</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-62 24,-82 256,-82 256,-62 24,-62" /><text text-anchor="start" x="27" y="-68.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-68.8" font-family="Courier,monospace" font-size="14.00">im_class</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-42 24,-62 256,-62 256,-42 24,-42" /><text text-anchor="start" x="27" y="-48.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-48.8" font-family="Courier,monospace" font-size="14.00">im_weakreflist</text></g><g id="edge1" class="edge"><title>struct:f&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M257,-92C280.313,-92 305.269,-92 329.087,-92" /><polygon fill="black" stroke="black" stroke-width="0.5" points="329.277,-94.6251 336.777,-92 329.277,-89.3751 329.277,-94.6251" /></g></g></svg>

<p>The four gray fields of the struct come from
<a href="https://github.com/python/cpython/blob/2.7/Include/object.h#L78"><code class="highlighter-rouge">PyObject_HEAD</code></a>,
which exist in all Python objects. The first two fields are from
<a href="https://github.com/python/cpython/blob/2.7/Include/object.h#L66"><code class="highlighter-rouge">_PyObject_HEAD_EXTRA</code></a>,
and only exist when the debugging macro <code class="highlighter-rouge">Py_TRACE_REFS</code> is defined, in order to
support more advanced reference counting. We can see that the <code class="highlighter-rouge">im_self</code> field,
which mantains the reference to our target object, is either forth or sixth in
the struct depending on <code class="highlighter-rouge">Py_TRACE_REFS</code>. If we can figure out the size of the
field and its offset from the start of the struct, then we can set its value
directly using <code class="highlighter-rouge">ctypes.memmove()</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ctypes</span><span class="o">.</span><span class="n">memmove</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="n">field_size</span><span class="p">)</span></code></pre></figure>

<p>Here, <code class="highlighter-rouge">id(f)</code> is the memory location of our method, which refers to the start
of the C struct from above. <code class="highlighter-rouge">offset</code> is the number of bytes between this memory
location and the start of the <code class="highlighter-rouge">im_self</code> field. We use
<a href="https://docs.python.org/2/library/ctypes.html#ctypes.byref"><code class="highlighter-rouge">ctypes.byref()</code></a>
to create a reference to the replacement object, <code class="highlighter-rouge">b</code>, which will be copied over
the existing reference to <code class="highlighter-rouge">a</code>. Finally, <code class="highlighter-rouge">field_size</code> is the number of bytes
we’re copying, equal to the size of the <code class="highlighter-rouge">im_self</code> field.</p>

<p>Well, all but one of these fields are pointers to structure types, meaning they
have the same size,<sup><a id="ref5" href="#fn5">[5]</a></sup> equal to
<a href="https://docs.python.org/2/library/ctypes.html#ctypes.sizeof"><code class="highlighter-rouge">ctypes.sizeof(ctypes.py_object)</code></a>.
This is (probably) 4 or 8 bytes, depending on whether you’re on a 32-bit or a
64-bit system. The other field is a <code class="highlighter-rouge">Py_ssize_t</code> object—possibly the same size
as the pointers, but we can’t be sure—which is equal to
<code class="highlighter-rouge">ctypes.sizeof(ctypes.c_ssize_t)</code>.</p>

<p>We know that <code class="highlighter-rouge">field_size</code> must be <code class="highlighter-rouge">ctypes.sizeof(ctypes.py_object)</code>, since we
are copying a structure pointer. <code class="highlighter-rouge">offset</code> is this value multiplied by the
number of structure pointers before <code class="highlighter-rouge">im_self</code> (4 if <code class="highlighter-rouge">Py_TRACE_REFS</code> is defined
and 2 otherwise), plus <code class="highlighter-rouge">ctypes.sizeof(ctypes.c_ssize_t)</code> for <code class="highlighter-rouge">ob_type</code>. But how
do we determine if <code class="highlighter-rouge">Py_TRACE_REFS</code> is defined? We can’t check the value of a
macro at runtime, but we can check for the existence of
<a href="https://github.com/python/cpython/blob/2.7/Misc/SpecialBuilds.txt#L54"><code class="highlighter-rouge">sys.getobjects()</code></a>,
which is
<a href="https://github.com/python/cpython/blob/2.7/Python/sysmodule.c#L951">only defined when that macro is</a>.
Therefore, we can make our replacement like so:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; import sys
&gt;&gt;&gt; field_size = ctypes.sizeof(ctypes.py_object)
&gt;&gt;&gt; ptrs_in_struct = 4 if hasattr(sys, "getobjects") else 2
&gt;&gt;&gt; offset = ptrs_in_struct * field_size + ctypes.sizeof(ctypes.c_ssize_t)
&gt;&gt;&gt; ctypes.memmove(id(f) + offset, ctypes.byref(ctypes.py_object(b)), field_size)
4470258440
&gt;&gt;&gt; f.__self__ is b
True
&gt;&gt;&gt; f()
&lt;__main__.B object at 0x10a8af290&gt;</code></pre></figure>

<p>Excellent—it worked!</p>

<p>There’s another kind of bound method, which is the built-in variety as opposed
to the user-defined variety we saw above. An example is <code class="highlighter-rouge">a.__sizeof__()</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; f = a.__sizeof__
&gt;&gt;&gt; f
&lt;built-in method __sizeof__ of A object at 0x10ab44b50&gt;
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; f.__self__
&lt;__main__.A object at 0x10ab44b50&gt;</code></pre></figure>

<p>This is stored internally as a
<a href="https://github.com/python/cpython/blob/2.7/Include/methodobject.h#L81"><code class="highlighter-rouge">PyCFunctionObject</code></a>.
Let’s take a look at its layout:</p>

<svg width="559pt" height="180pt" viewbox="0.00 18.00 559.03 180.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 206)"><polygon fill="white" stroke="none" points="-4,4 -4,-206 555.032,-206 555.032,4 -4,4" /><g id="clust2" class="cluster"><title>cluster</title><polygon fill="none" stroke="black" stroke-width="0" points="8,-8 8,-194 272,-194 272,-8 8,-8" /><text text-anchor="middle" x="140" y="-14.8" font-family="Courier,monospace" font-size="14.00">PyCFunctionObject</text></g><g id="node1" class="node"><title>obj</title><polygon fill="none" stroke="black" stroke-width="0.5" points="551.048,-90 336.984,-90 336.984,-54 551.048,-54 551.048,-90" /><text text-anchor="middle" x="444.016" y="-69" font-family="Courier,monospace" font-size="10.00">&lt;__main__.A object at 0xdeadbeef&gt;</text></g><g id="node2" class="node"><title>struct</title><polygon fill="#eeeeee" stroke="none" points="24,-162 24,-182 256,-182 256,-162 24,-162" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-162 24,-182 256,-182 256,-162 24,-162" /><text text-anchor="start" x="27" y="-168.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _object* </text><text text-anchor="start" x="161.422" y="-168.8" font-family="Courier,monospace" font-style="oblique" font-size="14.00" fill="#666666">_ob_next</text><polygon fill="#eeeeee" stroke="none" points="24,-142 24,-162 256,-162 256,-142 24,-142" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-142 24,-162 256,-162 256,-142 24,-142" /><text text-anchor="start" x="27" y="-148.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _object* </text><text text-anchor="start" x="161.422" y="-148.8" font-family="Courier,monospace" font-style="oblique" font-size="14.00" fill="#666666">_ob_prev</text><polygon fill="#eeeeee" stroke="none" points="24,-122 24,-142 256,-142 256,-122 24,-122" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-122 24,-142 256,-142 256,-122 24,-122" /><text text-anchor="start" x="27" y="-128.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">Py_ssize_t </text><text text-anchor="start" x="119.415" y="-128.8" font-family="Courier,monospace" font-size="14.00">ob_refcnt</text><polygon fill="#eeeeee" stroke="none" points="24,-102 24,-122 256,-122 256,-102 24,-102" /><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-102 24,-122 256,-122 256,-102 24,-102" /><text text-anchor="start" x="26.5815" y="-108.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">struct _typeobject* </text><text text-anchor="start" x="194.609" y="-108.8" font-family="Courier,monospace" font-size="14.00">ob_type</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-82 24,-102 256,-102 256,-82 24,-82" /><text text-anchor="start" x="27" y="-88.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyMethodDef* </text><text text-anchor="start" x="136.218" y="-88.8" font-family="Courier,monospace" font-size="14.00">m_ml</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-62 24,-82 256,-82 256,-62 24,-62" /><text text-anchor="start" x="27" y="-68.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-68.8" font-family="Courier,monospace" font-size="14.00">m_self</text><polygon fill="none" stroke="black" stroke-width="0.5" points="24,-42 24,-62 256,-62 256,-42 24,-42" /><text text-anchor="start" x="27" y="-48.8" font-family="Courier,monospace" font-size="14.00" fill="#888888">PyObject* </text><text text-anchor="start" x="111.014" y="-48.8" font-family="Courier,monospace" font-size="14.00">m_module</text></g><g id="edge1" class="edge"><title>struct:f&#45;&gt;obj</title><path fill="none" stroke="black" stroke-width="0.5" d="M257,-72C280.313,-72 305.269,-72 329.087,-72" /><polygon fill="black" stroke="black" stroke-width="0.5" points="329.277,-74.6251 336.777,-72 329.277,-69.3751 329.277,-74.6251" /></g></g></svg>

<p>Fortunately, <code class="highlighter-rouge">m_self</code> here has the same offset as <code class="highlighter-rouge">im_self</code> from before, so we
can just use the same code:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; ctypes.memmove(id(f) + offset, ctypes.byref(ctypes.py_object(b)), field_size)
4474703768
&gt;&gt;&gt; f.__self__ is b
True
&gt;&gt;&gt; f
&lt;built-in method __sizeof__ of B object at 0x10ab4f150&gt;</code></pre></figure>

<h3 id="dictionary-keys">Dictionary keys</h3>

<p>Dictionary keys have a different reference relation type than values, but the
replacement works mostly the same way. We pop the value of the old key from the
dictionary, and then insert it in again under the new key. Here’s the code,
which we’ll stick into the main block in <code class="highlighter-rouge">replace()</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relation</span><span class="p">,</span> <span class="n">Path</span><span class="o">.</span><span class="n">R_INDEXKEY</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">theone</span>
    <span class="n">source</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="n">relation</span><span class="o">.</span><span class="n">r</span><span class="p">])</span></code></pre></figure>

<p>And, a demonstration:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; d = {a: 1}
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; d
{&lt;__main__.B object at 0x10fb47950&gt;: 1}</code></pre></figure>

<h3 id="closure-cells">Closure cells</h3>

<p>We’ll cover just one more case, this time involving a
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>. Here’s
our test function:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="n">inner</span></code></pre></figure>

<p>As we can see, an instance of the inner function keeps references to the locals
of the wrapper function, even after using our current
version of <code class="highlighter-rouge">replace()</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; a, b = A(), B()
&gt;&gt;&gt; f = wrapper(a)
&gt;&gt;&gt; f()
&lt;__main__.A object at 0x109446090&gt;
&gt;&gt;&gt; replace(a, b)
&gt;&gt;&gt; f()
&lt;__main__.A object at 0x109446090&gt;</code></pre></figure>

<p>Internally, CPython implements this using things called
<a href="https://docs.python.org/2/c-api/cell.html"><em>cells</em></a>. We notice that
<code class="highlighter-rouge">f.func_closure</code> gives us a tuple of <code class="highlighter-rouge">cell</code> objects, and we can examine an
individual cell’s contents with <code class="highlighter-rouge">.cell_contents</code>:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; f.func_closure
(&lt;cell at 0x10ad9f478: instance object at 0x109446090&gt;,)
&gt;&gt;&gt; f.func_closure[0].cell_contents
&lt;__main__.A object at 0x109446090&gt;</code></pre></figure>

<p>As expected, we can’t just modify it…</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; f.func_closure[0].cell_contents = b
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: attribute 'cell_contents' of 'cell' objects is not writable</code></pre></figure>

<p>…because that would be too easy. So, how can we replace it? Well, we could
go back to <code class="highlighter-rouge">memmove</code>, but there’s an easier way thanks to the <code class="highlighter-rouge">ctypes</code> module
also exposing Python’s C API. Specifically, the
<a href="https://docs.python.org/2/c-api/cell.html#c.PyCell_Set"><code class="highlighter-rouge">PyCell_Set</code></a> function
(which seems to lack a pure Python equivalent) does exactly what we want. Since
the function expects <code class="highlighter-rouge">PyObject*</code>s as arguments, we’ll need to use
<code class="highlighter-rouge">ctypes.py_object</code> as a wrapper. Here it is:</p>

<figure class="highlight"><pre><code class="language-pycon" data-lang="pycon">&gt;&gt;&gt; from ctypes import py_object, pythonapi
&gt;&gt;&gt; pythonapi.PyCell_Set(py_object(f.func_closure[0]), py_object(b))
0
&gt;&gt;&gt; f()
&lt;__main__.B object at 0x10ad94dd0&gt;</code></pre></figure>

<p>Perfect – the replacement worked. To tie it together with <code class="highlighter-rouge">replace()</code>, we’ll
note that Guppy represents the cell contents relationship with
<code class="highlighter-rouge">Based_R_INTERATTR</code>, for what I assume to be “internal attribute”. We can use
this to find the cell object within the inner function that references our
target object, and then use the method above to make the change:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relation</span><span class="p">,</span> <span class="n">Path</span><span class="o">.</span><span class="n">R_INTERATTR</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">CellType</span><span class="p">):</span>
        <span class="n">pythonapi</span><span class="o">.</span><span class="n">PyCell_Set</span><span class="p">(</span><span class="n">py_object</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">py_object</span><span class="p">(</span><span class="n">new</span><span class="p">))</span>
        <span class="k">return</span></code></pre></figure>

<h3 id="other-cases">Other cases</h3>

<p>There are many, many more types of possible replacements. I’ve written a more
extensible version of <code class="highlighter-rouge">replace()</code> with some test cases, which can be viewed
on Gist <a href="https://gist.github.com/earwig/28a64ffb94d51a608e3d">here</a>.</p>

<p>Certainly, not every case is handled by it, but it seems to cover the majority
that I’ve found through testing. There are a number of reference relations in
Guppy that I couldn’t figure out how to replicate without doing something
insane (<code class="highlighter-rouge">R_HASATTR</code>, <code class="highlighter-rouge">R_CELL</code>, and <code class="highlighter-rouge">R_STACK</code>), so some obscure replacements are
likely unimplemented.</p>

<p>Some other kinds of replacements are known, but impossible. For example,
replacing a class object that uses <code class="highlighter-rouge">__slots__</code> with another class will not work
if the replacement class has a different slot layout and instances of the old
class exist. More generally, replacing a class with a non-class object won’t
work if instances of the class exist. Furthermore, references stored in data
structures managed by C extensions cannot be changed, since there’s no good way
for us to track these.</p>

<h2 id="footnotes">Footnotes</h2>

<ol>
  <li>
    <p><a id="fn1" href="#ref1">^</a> This post relies <em>heavily</em> on implementation
details of CPython 2.7. While it could be adapted for Python 3 by examining
changes to the internal structures of objects that we used above, that would
be a lost cause if you wanted to replicate this on
<a href="http://www.jython.org/">Jython</a> or some other implementation. We are so
dependent on concepts specific to CPython that you would need to start from
scratch, beginning with a language-specific replacement for Guppy.</p>
  </li>
  <li>
    <p><a id="fn2" href="#ref2">^</a> The
<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT files</a>
used to generate graphs in this post are
<a href="https://gist.github.com/earwig/edc13f04f871c110eea6">available on Gist</a>.</p>
  </li>
  <li>
    <p><a id="fn3" href="#ref3">^</a> They’re actually grouped together by <em>clodo</em>
(“class or dict object”), which is similar to type, but groups <code class="highlighter-rouge">__dict__</code>s
separately by their owner’s type.</p>
  </li>
  <li>
    <p><a id="fn4" href="#ref4">^</a> Python’s documentation tells us not to modify
the locals dictionary, but screw that; we’re gonna do it anyway.</p>
  </li>
  <li>
    <p><a id="fn5" href="#ref5">^</a> According to the
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a> and
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">C11 standards</a>;
section 6.2.5.27 in the former and 6.2.5.28 in the latter: “All pointers to
structure types shall have the same representation and alignment
requirements as each other.”</p>
  </li>
</ol>

    </div>
    
        <div id="disqus_thread"></div>
        <script>
            var disqus_shortname = 'syfy';
            var disqus_identifier = '/2015/01/28/python-object-replacement';
            var disqus_title = 'Finding and Replacing Objects in Python';
            var disqus_url = 'https://byetimes.com/2015/01/28/python-object-replacement.html';
            var disqus_developer = 1;
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
</div>

            <div id="footer">
                <p>Copyright &copy; 2011&ndash;2017 再&nbsp;见 &bull; 
                <a href="https://github.com/myyyy/myyyy.github.io">View&nbsp;Source</a> &bull; 
                <!-- <a href="http://validator.w3.org/check?uri=referer">Valid&nbsp;HTML5</a> -->
                </p>
            </div>
        </div>
    </body>
</html>
